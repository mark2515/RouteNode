package moe.group13.routenode.utils

import android.graphics.Typeface
import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.style.StyleSpan
import android.text.style.BulletSpan
import android.text.style.RelativeSizeSpan
import android.text.style.TypefaceSpan
import android.text.style.ForegroundColorSpan
import android.widget.TextView
import androidx.core.content.ContextCompat
import moe.group13.routenode.R

// This file is generated by GPT
object MarkdownRenderer {
    
    fun render(textView: TextView, markdown: String?) {
        if (markdown.isNullOrBlank()) {
            textView.text = ""
            return
        }
        
        val spannableBuilder = SpannableStringBuilder()
        val lines = markdown.split("\n")
        var inCodeBlock = false
        val codeBlockLines = mutableListOf<String>()
        
        for (i in lines.indices) {
            val line = lines[i]
            
            // Handle code blocks (```)
            if (line.trim().startsWith("```")) {
                if (inCodeBlock) {
                    // End of code block
                    inCodeBlock = false
                    if (codeBlockLines.isNotEmpty()) {
                        appendCodeBlock(spannableBuilder, codeBlockLines.joinToString("\n"), textView)
                        codeBlockLines.clear()
                    }
                } else {
                    // Start of code block
                    inCodeBlock = true
                }
                continue
            }
            
            if (inCodeBlock) {
                codeBlockLines.add(line)
                continue
            }
            
            // Process regular lines
            when {
                // Headers
                line.startsWith("### ") -> {
                    appendHeader(spannableBuilder, line.substring(4), 3, textView)
                }
                line.startsWith("## ") -> {
                    appendHeader(spannableBuilder, line.substring(3), 2, textView)
                }
                line.startsWith("# ") -> {
                    appendHeader(spannableBuilder, line.substring(2), 1, textView)
                }
                // Bullet lists
                line.trimStart().startsWith("- ") || line.trimStart().startsWith("* ") -> {
                    appendBulletPoint(spannableBuilder, line.trimStart().substring(2), textView)
                }
                // Numbered lists
                line.trimStart().matches(Regex("^\\d+\\.\\s.*")) -> {
                    val text = line.trimStart().replaceFirst(Regex("^\\d+\\.\\s"), "")
                    val number = line.trimStart().takeWhile { it.isDigit() }
                    appendNumberedPoint(spannableBuilder, text, number, textView)
                }
                // Regular text
                else -> {
                    appendFormattedLine(spannableBuilder, line, textView)
                }
            }
            
            // Add line break if not the last line
            if (i < lines.size - 1) {
                spannableBuilder.append("\n")
            }
        }
        
        textView.text = spannableBuilder
    }
    
    private fun appendHeader(
        builder: SpannableStringBuilder,
        text: String,
        level: Int,
        textView: TextView
    ) {
        val start = builder.length
        builder.append(text)
        val end = builder.length
        
        // Size based on header level
        val size = when (level) {
            1 -> 1.5f
            2 -> 1.3f
            3 -> 1.15f
            else -> 1.0f
        }
        
        builder.setSpan(RelativeSizeSpan(size), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        builder.setSpan(StyleSpan(Typeface.BOLD), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        
        // Add color for headers
        val color = ContextCompat.getColor(textView.context, R.color.primaryColor)
        builder.setSpan(ForegroundColorSpan(color), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
    }
    
    private fun appendBulletPoint(
        builder: SpannableStringBuilder,
        text: String,
        textView: TextView
    ) {
        val start = builder.length
        builder.append(text)
        val end = builder.length
        
        // Add bullet span
        val bulletColor = ContextCompat.getColor(textView.context, R.color.textColorSecondary)
        val bulletSpan = BulletSpan(20, bulletColor)
        builder.setSpan(bulletSpan, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        
        // Apply inline formatting
        applyInlineFormatting(builder, start, end, textView)
    }
    
    private fun appendNumberedPoint(
        builder: SpannableStringBuilder,
        text: String,
        number: String,
        textView: TextView
    ) {
        val start = builder.length
        builder.append("$number. $text")
        val end = builder.length
        
        // Apply inline formatting
        applyInlineFormatting(builder, start, end, textView)
    }
    
    private fun appendCodeBlock(
        builder: SpannableStringBuilder,
        code: String,
        textView: TextView
    ) {
        val start = builder.length
        builder.append(code)
        val end = builder.length
        
        // Monospace font
        builder.setSpan(TypefaceSpan("monospace"), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        
        // Smaller size
        builder.setSpan(RelativeSizeSpan(0.9f), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        
        // Background color effect
        val codeColor = ContextCompat.getColor(textView.context, R.color.codeTextColor)
        builder.setSpan(ForegroundColorSpan(codeColor), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
    }
    
    private fun appendFormattedLine(
        builder: SpannableStringBuilder,
        line: String,
        textView: TextView
    ) {
        val start = builder.length
        builder.append(line)
        val end = builder.length
        
        applyInlineFormatting(builder, start, end, textView)
    }
    
    private fun applyInlineFormatting(
        builder: SpannableStringBuilder,
        start: Int,
        end: Int,
        textView: TextView
    ) {
        val text = builder.substring(start, end)
        
        // Bold (**text** or __text__)
        applyPattern(builder, start, text, Regex("\\*\\*(.+?)\\*\\*")) { matchStart, matchEnd ->
            builder.setSpan(StyleSpan(Typeface.BOLD), matchStart, matchEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        }
        applyPattern(builder, start, text, Regex("__(.+?)__")) { matchStart, matchEnd ->
            builder.setSpan(StyleSpan(Typeface.BOLD), matchStart, matchEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        }
        
        // Italic (*text* or _text_)
        applyPattern(builder, start, text, Regex("(?<!\\*)\\*(?!\\*)(.+?)(?<!\\*)\\*(?!\\*)")) { matchStart, matchEnd ->
            builder.setSpan(StyleSpan(Typeface.ITALIC), matchStart, matchEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        }
        applyPattern(builder, start, text, Regex("(?<!_)_(?!_)(.+?)(?<!_)_(?!_)")) { matchStart, matchEnd ->
            builder.setSpan(StyleSpan(Typeface.ITALIC), matchStart, matchEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        }
        
        // Inline code (`code`)
        applyPattern(builder, start, text, Regex("`(.+?)`")) { matchStart, matchEnd ->
            builder.setSpan(TypefaceSpan("monospace"), matchStart, matchEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            val codeColor = ContextCompat.getColor(textView.context, R.color.codeTextColor)
            builder.setSpan(ForegroundColorSpan(codeColor), matchStart, matchEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        }
        
        // Strikethrough (~~text~~)
        applyPattern(builder, start, text, Regex("~~(.+?)~~")) { matchStart, matchEnd ->
            builder.setSpan(
                android.text.style.StrikethroughSpan(),
                matchStart,
                matchEnd,
                Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
            )
        }
    }
    
    private fun applyPattern(
        builder: SpannableStringBuilder,
        offset: Int,
        text: String,
        pattern: Regex,
        applySpan: (Int, Int) -> Unit
    ) {
        val matches = pattern.findAll(text)
        for (match in matches) {
            val matchStart = offset + match.range.first
            val matchEnd = offset + match.range.last + 1
            val groupStart = offset + match.groups[1]!!.range.first
            val groupEnd = offset + match.groups[1]!!.range.last + 1
            
            // Apply the span to the content
            applySpan(groupStart, groupEnd)
        }
    }
    
    fun cleanMarkdown(markdown: String?): String {
        if (markdown.isNullOrBlank()) return ""
        
        var cleaned = markdown
        
        // Remove headers
        cleaned = cleaned.replace(Regex("^#{1,6}\\s"), "")
        
        // Remove bold
        cleaned = cleaned.replace(Regex("\\*\\*(.+?)\\*\\*"), "$1")
        cleaned = cleaned.replace(Regex("__(.+?)__"), "$1")
        
        // Remove italic
        cleaned = cleaned.replace(Regex("\\*(.+?)\\*"), "$1")
        cleaned = cleaned.replace(Regex("_(.+?)_"), "$1")
        
        // Remove code
        cleaned = cleaned.replace(Regex("`(.+?)`"), "$1")
        cleaned = cleaned.replace(Regex("```(.+?)```"), "$1")
        
        // Remove strikethrough
        cleaned = cleaned.replace(Regex("~~(.+?)~~"), "$1")
        
        return cleaned
    }
}