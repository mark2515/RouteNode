package moe.group13.routenode.utils

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.graphics.Typeface
import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.style.StyleSpan
import android.text.style.BulletSpan
import android.text.style.RelativeSizeSpan
import android.text.style.TypefaceSpan
import android.text.style.ForegroundColorSpan
import android.text.style.StrikethroughSpan
import android.text.style.ClickableSpan
import android.text.style.UnderlineSpan
import android.text.style.BackgroundColorSpan
import android.text.method.LinkMovementMethod
import android.view.View
import android.widget.TextView
import android.widget.Toast
import androidx.core.content.ContextCompat
import moe.group13.routenode.R

// This file is generated by GPT
object MarkdownRenderer {
    
    private class CopyableCodeSpan(
        private val context: Context,
        private val codeContent: String
    ) : ClickableSpan() {
        
        override fun onClick(widget: View) {
            // Copy to clipboard
            val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
            val clip = ClipData.newPlainText("Code", codeContent)
            clipboard.setPrimaryClip(clip)
            Toast.makeText(context, "Copied to clipboard", Toast.LENGTH_SHORT).show()
        }
        
        override fun updateDrawState(ds: android.text.TextPaint) {
            super.updateDrawState(ds)
            ds.isUnderlineText = false
        }
    }
    
    fun render(textView: TextView, markdown: String?) {
        if (markdown.isNullOrBlank()) {
            textView.text = ""
            return
        }
        
        // Enable clickable spans
        textView.movementMethod = LinkMovementMethod.getInstance()
        
        val spannableBuilder = SpannableStringBuilder()
        val lines = markdown.split("\n")
        var inCodeBlock = false
        val codeBlockLines = mutableListOf<String>()
        
        for (i in lines.indices) {
            val line = lines[i]
            
            // Handle code blocks (```)
            if (line.trim().startsWith("```")) {
                if (inCodeBlock) {
                    // End of code block
                    inCodeBlock = false
                    if (codeBlockLines.isNotEmpty()) {
                        appendCodeBlock(spannableBuilder, codeBlockLines.joinToString("\n"), textView)
                        codeBlockLines.clear()
                    }
                } else {
                    // Start of code block
                    inCodeBlock = true
                }
                continue
            }
            
            if (inCodeBlock) {
                codeBlockLines.add(line)
                continue
            }
            
            // Process regular lines
            when {
                // Headers
                line.startsWith("### ") -> {
                    appendHeader(spannableBuilder, line.substring(4), 3, textView)
                }
                line.startsWith("## ") -> {
                    appendHeader(spannableBuilder, line.substring(3), 2, textView)
                }
                line.startsWith("# ") -> {
                    appendHeader(spannableBuilder, line.substring(2), 1, textView)
                }
                // Bullet lists
                line.trimStart().startsWith("- ") || line.trimStart().startsWith("* ") -> {
                    appendBulletPoint(spannableBuilder, line.trimStart().substring(2), textView)
                }
                // Numbered lists
                line.trimStart().matches(Regex("^\\d+\\.\\s.*")) -> {
                    val text = line.trimStart().replaceFirst(Regex("^\\d+\\.\\s"), "")
                    val number = line.trimStart().takeWhile { it.isDigit() }
                    appendNumberedPoint(spannableBuilder, text, number, textView)
                }
                // Regular text
                else -> {
                    appendFormattedLine(spannableBuilder, line, textView)
                }
            }
            
            // Add line break if not the last line
            if (i < lines.size - 1) {
                spannableBuilder.append("\n")
            }
        }
        
        textView.text = spannableBuilder
    }
    
    private fun appendHeader(
        builder: SpannableStringBuilder,
        text: String,
        level: Int,
        textView: TextView
    ) {
        val processedText = processInlineMarkdown(text, builder, builder.length, textView)
    }
    
    private fun appendBulletPoint(
        builder: SpannableStringBuilder,
        text: String,
        textView: TextView
    ) {
        val start = builder.length
        processInlineMarkdown(text, builder, start, textView)
        val end = builder.length
        
        // Add bullet span
        val bulletColor = ContextCompat.getColor(textView.context, R.color.textColorSecondary)
        val bulletSpan = BulletSpan(20, bulletColor)
        builder.setSpan(bulletSpan, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
    }
    
    private fun appendNumberedPoint(
        builder: SpannableStringBuilder,
        text: String,
        number: String,
        textView: TextView
    ) {
        val start = builder.length
        builder.append("$number. ")
        processInlineMarkdown(text, builder, builder.length, textView)
    }
    
    private fun appendCodeBlock(
        builder: SpannableStringBuilder,
        code: String,
        textView: TextView
    ) {
        val start = builder.length
        builder.append("ðŸ“‹ ")
        val iconEnd = builder.length
        
        // Add the code content
        builder.append(code)
        val end = builder.length
        
        // Apply background to entire code block including icon
        val backgroundColor = ContextCompat.getColor(textView.context, R.color.codeBackgroundColor)
        builder.setSpan(BackgroundColorSpan(backgroundColor), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        
        // Monospace font for code content
        builder.setSpan(TypefaceSpan("monospace"), iconEnd, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        
        // Code color
        val codeColor = ContextCompat.getColor(textView.context, R.color.codeTextColor)
        builder.setSpan(ForegroundColorSpan(codeColor), iconEnd, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        
        // Make the entire code block clickable to copy
        val clickableSpan = CopyableCodeSpan(textView.context, code)
        builder.setSpan(clickableSpan, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        
        // Add subtle underline to show it's clickable
        builder.setSpan(UnderlineSpan(), start, iconEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
    }
    
    private fun appendFormattedLine(
        builder: SpannableStringBuilder,
        line: String,
        textView: TextView
    ) {
        processInlineMarkdown(line, builder, builder.length, textView)
    }
    
    private fun processInlineMarkdown(
        text: String,
        builder: SpannableStringBuilder,
        startOffset: Int,
        textView: TextView
    ) {
        var remaining = text
        var currentPos = startOffset
        
        while (remaining.isNotEmpty()) {
            // Find the earliest markdown pattern
            val patterns = listOf(
                Triple(Regex("^\\*\\*([^*]+?)\\*\\*"), 2, "bold"),     // **bold**
                Triple(Regex("^__([^_]+?)__"), 2, "bold"),             // __bold__
                Triple(Regex("^(?<!\\*)\\*([^*]+?)\\*"), 1, "italic"), // *italic*
                Triple(Regex("^(?<!_)_([^_]+?)_"), 1, "italic"),       // _italic_
                Triple(Regex("^`([^`]+?)`"), 1, "code"),               // `code`
                Triple(Regex("^~~([^~]+?)~~"), 2, "strike")            // ~~strike~~
            )
            
            var matched = false
            
            for ((pattern, syntaxLen, type) in patterns) {
                val match = pattern.find(remaining)
                if (match != null) {
                    val content = match.groupValues[1]
                    val matchLength = match.value.length
                    
                    // Append the content without markdown syntax
                    val contentStart = builder.length
                    builder.append(content)
                    val contentEnd = builder.length
                    
                    // Apply appropriate span
                    when (type) {
                        "bold" -> {
                            builder.setSpan(StyleSpan(Typeface.BOLD), contentStart, contentEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                        }
                        "italic" -> {
                            builder.setSpan(StyleSpan(Typeface.ITALIC), contentStart, contentEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                        }
                        "code" -> {
                            // Make inline code clickable to copy
                            builder.setSpan(TypefaceSpan("monospace"), contentStart, contentEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                            val codeColor = ContextCompat.getColor(textView.context, R.color.codeTextColor)
                            builder.setSpan(ForegroundColorSpan(codeColor), contentStart, contentEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                            
                            // Add background for inline code
                            val backgroundColor = ContextCompat.getColor(textView.context, R.color.codeBackgroundColor)
                            builder.setSpan(BackgroundColorSpan(backgroundColor), contentStart, contentEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                            
                            // Make clickable to copy
                            val clickableSpan = CopyableCodeSpan(textView.context, content)
                            builder.setSpan(clickableSpan, contentStart, contentEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                        }
                        "strike" -> {
                            builder.setSpan(StrikethroughSpan(), contentStart, contentEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                        }
                    }
                    
                    // Update remaining text
                    remaining = remaining.substring(matchLength)
                    matched = true
                    break
                }
            }
            
            if (!matched) {
                // No pattern matched, just append the next character
                builder.append(remaining[0])
                remaining = remaining.substring(1)
            }
        }
    }
    
    fun cleanMarkdown(markdown: String?): String {
        if (markdown.isNullOrBlank()) return ""
        
        var cleaned = markdown
        
        // Remove code blocks first
        cleaned = cleaned.replace(Regex("```[\\s\\S]*?```"), "")
        
        // Remove headers
        cleaned = cleaned.replace(Regex("(?m)^#{1,6}\\s"), "")
        
        // Remove bold
        cleaned = cleaned.replace(Regex("\\*\\*(.+?)\\*\\*"), "$1")
        cleaned = cleaned.replace(Regex("__(.+?)__"), "$1")
        
        // Remove italic
        cleaned = cleaned.replace(Regex("(?<!\\*)\\*([^*]+?)\\*(?!\\*)"), "$1")
        cleaned = cleaned.replace(Regex("(?<!_)_([^_]+?)_(?!_)"), "$1")
        
        // Remove inline code
        cleaned = cleaned.replace(Regex("`([^`]+?)`"), "$1")
        
        // Remove strikethrough
        cleaned = cleaned.replace(Regex("~~(.+?)~~"), "$1")
        
        // Remove bullet points
        cleaned = cleaned.replace(Regex("(?m)^[*-]\\s"), "")
        
        return cleaned
    }
}